import threading
from kortex_api.autogen.messages import Base_pb2
from kortex_api.autogen.messages import BaseCyclic_pb2  # if used

TIMEOUT_DURATION = 20


def check_for_end_or_abort(e):
    """
    Return a closure checking for END or ABORT notifications.
    """
    def check(notification, e=e):
        print("EVENT :", Base_pb2.ActionEvent.Name(notification.action_event))
        if (notification.action_event == Base_pb2.ACTION_END or
                notification.action_event == Base_pb2.ACTION_ABORT):
            e.set()
    return check


def example_move_to_home_position(base):
    """
    Move Kinova Gen3 to the predefined 'Home' position.
    """
    base_servo_mode = Base_pb2.ServoingModeInformation()
    base_servo_mode.servoing_mode = Base_pb2.SINGLE_LEVEL_SERVOING
    base.SetServoingMode(base_servo_mode)

    print("Moving the arm to a safe (Home) position")
    action_type = Base_pb2.RequestedActionType()
    action_type.action_type = Base_pb2.REACH_JOINT_ANGLES
    action_list = base.ReadAllActions(action_type)
    action_handle = None
    for action in action_list.action_list:
        if action.name == "Home":
            action_handle = action.handle

    if action_handle is None:
        print("Can't reach Home position. Exiting")
        return False

    e = threading.Event()
    notification_handle = base.OnNotificationActionTopic(
        check_for_end_or_abort(e),
        Base_pb2.NotificationOptions()
    )

    base.ExecuteActionFromReference(action_handle)
    finished = e.wait(TIMEOUT_DURATION)
    base.Unsubscribe(notification_handle)

    if finished:
        print("Home position reached")
    else:
        print("Timeout on action notification wait")
    return finished


def cartesian_move(base, base_cyclic, dx=0.0, dy=0.0, dz=0.0,
                   dtx=0.0, dty=0.0, dtz=0.0, label="Cartesian move"):
    """
    Generic Cartesian move relative to current tool pose.
    """
    print(f"Starting {label} ...")
    action = Base_pb2.Action()
    action.name = label
    action.application_data = ""

    feedback = base_cyclic.RefreshFeedback()

    cartesian_pose = action.reach_pose.target_pose
    cartesian_pose.x = feedback.base.tool_pose_x + dx
    cartesian_pose.y = feedback.base.tool_pose_y + dy
    cartesian_pose.z = feedback.base.tool_pose_z + dz
    cartesian_pose.theta_x = feedback.base.tool_pose_theta_x + dtx
    cartesian_pose.theta_y = feedback.base.tool_pose_theta_y + dty
    cartesian_pose.theta_z = feedback.base.tool_pose_theta_z + dtz

    e = threading.Event()
    notification_handle = base.OnNotificationActionTopic(
        check_for_end_or_abort(e),
        Base_pb2.NotificationOptions()
    )

    print("Executing action")
    base.ExecuteAction(action)

    print("Waiting for movement to finish ...")
    finished = e.wait(TIMEOUT_DURATION)
    base.Unsubscribe(notification_handle)

    if finished:
        print("Cartesian movement completed")
    else:
        print("Timeout on action notification wait")
    return finished
